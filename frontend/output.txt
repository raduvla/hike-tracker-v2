===== FILE: ./apps/mobile/android/.gradle/8.10.2/dependencies-accessors/gc.properties =====


===== FILE: ./apps/mobile/android/.gradle/8.10.2/gc.properties =====


===== FILE: ./apps/mobile/android/.gradle/buildOutputCleanup/cache.properties =====
#Fri Oct 10 17:34:41 EEST 2025
gradle.version=8.10.2


===== FILE: ./apps/mobile/android/.gradle/vcs-1/gc.properties =====


===== FILE: ./apps/mobile/android/app/src/main/java/com/hiketracker/location/LocationModule.kt =====
package com.hiketracker.location

import android.annotation.SuppressLint
import android.content.Context
import android.os.Looper
import android.util.Log
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.bridge.ReactContextBaseJavaModule
import com.facebook.react.bridge.ReactMethod
import com.facebook.react.bridge.WritableMap
import com.facebook.react.bridge.Arguments
import com.facebook.react.modules.core.DeviceEventManagerModule
import com.google.android.gms.location.*

class LocationModule(reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext) {

    private val fusedClient: FusedLocationProviderClient =
        LocationServices.getFusedLocationProviderClient(reactContext)

    private var callback: LocationCallback? = null
    private var currentMode: TrackingMode = TrackingMode.MODERATE
    private var serviceStarted = false

    override fun getName(): String = "LocationModule"

    // Required for event emitter - even if empty
    @ReactMethod
    fun addListener(eventName: String) {
        // Keep: Required for RN built-in Event Emitter Calls.
    }

    @ReactMethod
    fun removeListeners(count: Int) {
        // Keep: Required for RN built-in Event Emitter Calls.
    }

    @ReactMethod
    fun setTrackingMode(mode: String) {
        currentMode = TrackingMode.fromString(mode)
        Log.d("LocationModule", "üìä Tracking mode set to: ${currentMode.displayName}")
        
        // If already tracking, restart with new settings
        if (callback != null) {
            stopUpdates()
            startUpdates()
        }
    }

    @SuppressLint("MissingPermission") // we request perms in JS before calling this
    @ReactMethod
    fun startUpdates() {
          Log.d("LocationModule", "üü¢ startUpdates() called")
        if (callback != null) {
             Log.d("LocationModule", "‚ö†Ô∏è Already running, returning")
            return // already running
        }

        // Start foreground service for background tracking
        if (!serviceStarted) {
            try {
                LocationService.start(reactApplicationContext, currentMode)
                serviceStarted = true
                Log.d("LocationModule", "‚úÖ Foreground service started")
            } catch (e: Exception) {
                Log.e("LocationModule", "‚ùå Failed to start service: ${e.message}")
            }
        }

         // Try to get last known location immediately
    fusedClient.lastLocation.addOnSuccessListener { location ->
        if (location != null) {
            Log.d("LocationModule", "üìç Got last known location: ${location.latitude}, ${location.longitude}")
           try {
              val event = Arguments.createMap()
                    event.putDouble("latitude", location.latitude)
                    event.putDouble("longitude", location.longitude)
                    event.putDouble("altitude", if (location.hasAltitude()) location.altitude else 0.0)
                    event.putDouble("accuracy", location.accuracy.toDouble())
                    event.putDouble("timestamp", location.time.toDouble())
                    sendEvent("LocationUpdate", event)
                    Log.d("LocationModule", "‚úÖ Sent last known location to JS")
           } catch (e: Exception) {
                    Log.e("LocationModule", "‚ùå Error sending last location: ${e.message}")
                }
            
        } else {
            Log.d("LocationModule", "‚ö†Ô∏è No last known location available")
        }
    }

        val request = LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, currentMode.updateIntervalMs)
            .setMinUpdateIntervalMillis(currentMode.minUpdateIntervalMs)
            .setMinUpdateDistanceMeters(currentMode.minDistanceMeters)
             .setMaxUpdateDelayMillis(currentMode.maxUpdateDelayMs) 
            .setWaitForAccurateLocation(false)
            .build()

            Log.d("LocationModule", "üü¢ Creating location callback")
            Log.d("LocationModule", "‚öôÔ∏è Config: interval=${currentMode.updateIntervalMs}ms, distance=${currentMode.minDistanceMeters}m")

        callback = object : LocationCallback() {
            override fun onLocationResult(result: LocationResult) {
                Log.d("LocationModule", "üìç Location result received!")
                val loc = result.lastLocation
                if (loc == null) {
                    Log.d("LocationModule", "‚ö†Ô∏è Location is null")
                    return
                }

                Log.d("LocationModule", "üìç Location: ${loc.latitude}, ${loc.longitude}, alt: ${if (loc.hasAltitude()) loc.altitude else 0.0}m")
                try {
                    val event = Arguments.createMap()
                    event.putDouble("latitude", loc.latitude)
                    event.putDouble("longitude", loc.longitude)
                    event.putDouble("altitude", if (loc.hasAltitude()) loc.altitude else 0.0)
                    event.putDouble("accuracy", loc.accuracy.toDouble())
                    event.putDouble("timestamp", loc.time.toDouble())
                    
                    Log.d("LocationModule", "üì§ Sending event to JS")
                    sendEvent("LocationUpdate", event)
                    Log.d("LocationModule", "‚úÖ Event sent successfully")
                } catch (e: Exception) {
                    Log.e("LocationModule", "‚ùå Error sending event: ${e.message}")
                }
            }
        }

        Log.d("LocationModule", "üü¢ Requesting location updates")
        fusedClient.requestLocationUpdates(
            request,
            callback as LocationCallback,
            Looper.getMainLooper()
        )
        Log.d("LocationModule", "‚úÖ Location updates requested successfully")
    }

    @ReactMethod
    fun stopUpdates() {
        Log.d("LocationModule", "üî¥ stopUpdates() called")
        callback?.let { fusedClient.removeLocationUpdates(it) }
        callback = null

             // Stop foreground service
        if (serviceStarted) {
            LocationService.stop(reactApplicationContext)
            serviceStarted = false
            Log.d("LocationModule", "‚úÖ Foreground service stopped")
        }
    }

    private fun sendEvent(eventName: String, params: WritableMap) {
        reactApplicationContext
            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
            ?.emit(eventName, params)
    }
}

===== FILE: ./apps/mobile/android/app/src/main/java/com/hiketracker/location/LocationPackage.kt =====
package com.hiketracker.location

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class LocationPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(LocationModule(reactContext))
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
}



===== FILE: ./apps/mobile/android/app/src/main/java/com/hiketracker/location/LocationService.kt =====
package com.hiketracker.location

// ‚úÖ FIXED: All imports at the top
import android.app.*
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.IBinder
import android.os.PowerManager
import android.util.Log
import androidx.core.app.NotificationCompat
import com.google.android.gms.location.*

class LocationService : Service() {

    // ‚úÖ FIXED: All properties declared
    private lateinit var fusedClient: FusedLocationProviderClient
    private lateinit var request: LocationRequest
    private var callback: LocationCallback? = null
    private var wakeLock: PowerManager.WakeLock? = null
    private var trackingMode: TrackingMode = TrackingMode.MODERATE
    
    companion object {
        private const val CHANNEL_ID = "hike_tracking"
        private const val NOTIFICATION_ID = 1
        private const val EXTRA_TRACKING_MODE = "tracking_mode"
        
        fun start(context: Context, mode: TrackingMode = TrackingMode.MODERATE) {
            val intent = Intent(context, LocationService::class.java).apply {
                putExtra(EXTRA_TRACKING_MODE, mode.name)
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.startForegroundService(intent)
            } else {
                context.startService(intent)
            }
        }
        
        fun stop(context: Context) {
            context.stopService(Intent(context, LocationService::class.java))
        }
    }

    override fun onCreate() {
        super.onCreate()
        Log.d("LocationService", "üü¢ Service onCreate")
        
        fusedClient = LocationServices.getFusedLocationProviderClient(this)
        
        createNotificationChannel()
        startForeground(NOTIFICATION_ID, createNotification())
        acquireWakeLock()
        // startLocationUpdates()
    }

       override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        Log.d("LocationService", "üü¢ Service onStartCommand")

        // Get tracking mode from intent
        intent?.getStringExtra(EXTRA_TRACKING_MODE)?.let { modeName ->
            trackingMode = TrackingMode.fromString(modeName)
            Log.d("LocationService", "üìä Using tracking mode: ${trackingMode.displayName}")
        }
        
        // Build request with tracking mode settings
        request = LocationRequest.Builder(
            trackingMode.priority,
            trackingMode.updateIntervalMs
        )
            .setMinUpdateIntervalMillis(trackingMode.minUpdateIntervalMs)
            .setMaxUpdateDelayMillis(trackingMode.maxUpdateDelayMs)
            .setMinUpdateDistanceMeters(trackingMode.minDistanceMeters)
            .setWaitForAccurateLocation(false)
            .build()
        
        startLocationUpdates()

        return START_STICKY
    }

    private fun acquireWakeLock() {
        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        wakeLock = powerManager.newWakeLock(
            PowerManager.PARTIAL_WAKE_LOCK,
            "HikeTracker::LocationWakeLock"
        )
        wakeLock?.acquire(10*60*1000L)
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Hike Tracking",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Background location tracking for hiking"
                setShowBadge(false)
            }
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(channel)
        }
    }

    private fun createNotification(): Notification {
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            packageManager.getLaunchIntentForPackage(packageName),
            PendingIntent.FLAG_IMMUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
        )

        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Tracking Hike  (${trackingMode.displayName})")
            .setContentText("Recording your location")
            .setSmallIcon(android.R.drawable.ic_menu_mylocation)
            .setContentIntent(pendingIntent)
            .setOngoing(true)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setCategory(NotificationCompat.CATEGORY_SERVICE)
            .build()
    }

    @android.annotation.SuppressLint("MissingPermission")
    private fun startLocationUpdates() {
        try {
            callback = object : LocationCallback() {
                override fun onLocationResult(result: LocationResult) {
                    result.lastLocation?.let { loc ->
                        Log.d("LocationService", "üìç Background location: ${loc.latitude}, ${loc.longitude}")
                        
                        val notificationManager = getSystemService(NotificationManager::class.java)
                        notificationManager.notify(
                            NOTIFICATION_ID,
                            createNotification()
                        )
                    }
                }
            }

            fusedClient.requestLocationUpdates(
                request,
                callback as LocationCallback,
                mainLooper
            )
            
            Log.d("LocationService", "‚úÖ Background location updates started")
             Log.d("LocationService", "‚öôÔ∏è Config: interval=${trackingMode.updateIntervalMs}ms, distance=${trackingMode.minDistanceMeters}m")
        } catch (e: SecurityException) {
            Log.e("LocationService", "‚ùå Missing location permission", e)
        }
    }

    override fun onDestroy() {
        Log.d("LocationService", "üî¥ Service onDestroy")
        callback?.let { fusedClient.removeLocationUpdates(it) }
        wakeLock?.release()
        super.onDestroy()
    }

    override fun onBind(intent: Intent?): IBinder? = null
}

===== FILE: ./apps/mobile/android/app/src/main/java/com/hiketracker/location/TrackingConfig.kt =====
package com.hiketracker.location

import com.google.android.gms.location.Priority

enum class TrackingMode(
    val priority: Int,
    val updateIntervalMs: Long,
    val minUpdateIntervalMs: Long,
    val maxUpdateDelayMs: Long,
    val minDistanceMeters: Float,
    val displayName: String,
    val description: String
) {
    REAL_TIME(
        priority = Priority.PRIORITY_HIGH_ACCURACY,
        updateIntervalMs = 3_000L,
        minUpdateIntervalMs = 2_000L,
        maxUpdateDelayMs = 5_000L,
        minDistanceMeters = 5f,
        displayName = "Real-Time",
        description = "Most accurate, highest battery usage"
    ),
    MODERATE(
        priority = Priority.PRIORITY_HIGH_ACCURACY,
        updateIntervalMs = 5_000L,
        minUpdateIntervalMs = 3_000L,
        maxUpdateDelayMs = 10_000L,
        minDistanceMeters = 10f,
        displayName = "Moderate",
        description = "Balanced accuracy and battery"
    ),
    BATTERY_EFFICIENT(
        priority = Priority.PRIORITY_BALANCED_POWER_ACCURACY,
        updateIntervalMs = 10_000L,
        minUpdateIntervalMs = 8_000L,
        maxUpdateDelayMs = 20_000L,
        minDistanceMeters = 20f,
        displayName = "Battery Efficient",
        description = "Lower accuracy, best battery life"
    );

    companion object {
        fun fromString(mode: String): TrackingMode {
            return when (mode.uppercase()) {
                "REAL_TIME" -> REAL_TIME
                "MODERATE" -> MODERATE
                "BATTERY_EFFICIENT" -> BATTERY_EFFICIENT
                else -> MODERATE // default
            }
        }
    }
}

===== FILE: ./apps/mobile/android/app/src/main/java/com/hiketracker/MainActivity.kt =====
package com.hiketracker

import com.facebook.react.ReactActivity
import com.facebook.react.ReactActivityDelegate
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabled
import com.facebook.react.defaults.DefaultReactActivityDelegate

class MainActivity : ReactActivity() {

  /**
   * Returns the name of the main component registered from JavaScript. This is used to schedule
   * rendering of the component.
   */
  override fun getMainComponentName(): String = "mobile"

  /**
   * Returns the instance of the [ReactActivityDelegate]. We use [DefaultReactActivityDelegate]
   * which allows you to enable New Architecture with a single boolean flags [fabricEnabled]
   */
  override fun createReactActivityDelegate(): ReactActivityDelegate =
      DefaultReactActivityDelegate(this, mainComponentName, fabricEnabled)


}


===== FILE: ./apps/mobile/android/app/src/main/java/com/hiketracker/MainApplication.kt =====
package com.hiketracker

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.soloader.SoLoader
import com.facebook.react.defaults.DefaultReactNativeHost
import com.hiketracker.location.LocationPackage // ‚úÖ adjust to your native package name

class MainApplication : Application(), ReactApplication {


    override val reactNativeHost: ReactNativeHost =
            object : DefaultReactNativeHost(this) {
                //override fun getPackages(): List<ReactPackage> =
                 //   PackageList(this).packages.apply {
                  //      add(LocationPackage())
                  override fun getPackages(): List<ReactPackage> {
                val packages = PackageList(this).packages.toMutableList()
                packages.add(LocationPackage())
                return packages
                    }

        
            override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG
            override fun getJSMainModuleName(): String = "index"
            //override val isNewArchEnabled: Boolean = false
            //override val isHermesEnabled: Boolean = true
        }

    //override val reactHost: ReactHost
    //    get() = getDefaultReactHost(applicationContext, reactNativeHost)


    override fun onCreate() {
        super.onCreate()
        SoLoader.init(this, false)
      //  if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      //      load()
       // }
    }
}

===== FILE: ./apps/mobile/android/gradle/wrapper/gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


===== FILE: ./apps/mobile/android/gradle.properties =====
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
# Default value: -Xmx512m -XX:MaxMetaspaceSize=256m
org.gradle.jvmargs=-Xmx2048m -XX:MaxMetaspaceSize=512m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true

# Use this property to specify which architecture you want to build.
# You can also override it from the CLI using
# ./gradlew <task> -PreactNativeArchitectures=x86_64
# reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64
reactNativeArchitectures=x86_64
# Use this property to enable support to the new architecture.
# This will allow you to use TurboModules and the Fabric render in
# your application. You should enable this flag either if you want
# to write custom TurboModules/Fabric components OR use libraries that
# are providing them.
newArchEnabled=false

# Use this property to enable or disable the Hermes JS engine.
# If set to false, you will be using JSC instead.
hermesEnabled=true

MYAPP_UPLOAD_STORE_FILE=trackster-release-key.keystore
MYAPP_UPLOAD_KEY_ALIAS=trackster-key-alias
MYAPP_UPLOAD_STORE_PASSWORD=mufasa13
MYAPP_UPLOAD_KEY_PASSWORD=mufasa13


===== FILE: ./apps/mobile/android/local.properties =====
sdk.dir=C:/Users/Vlad/AppData/Local/Android/Sdk


===== FILE: ./apps/mobile/app.json =====
{
  "name": "mobile",
  "displayName": "TrackSter"
}


===== FILE: ./apps/mobile/App.tsx =====
import { SafeAreaView, StatusBar, StyleSheet, useColorScheme, ActivityIndicator, View } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { AuthProvider } from './src/context/AuthContext';
import { useAuthStore } from '@hike-tracker/stores';
import LoginScreen from './src/screens/LoginScreen';
import SignupScreen from './src/screens/SignupScreen';
import MapScreen from './src/screens/MapScreen';


const Stack = createNativeStackNavigator();

unction Navigation() {
  const { user, isLoading } = useAuthStore();

  if (isLoading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#4CAF50" />
      </View>
    );
  }

  return (
    <NavigationContainer>
      <Stack.Navigator
        screenOptions={{
          headerShown: false,
        }}
      >
        {user ? (
          <Stack.Screen name="Map" component={MapScreen} />
        ) : (
          <>
            <Stack.Screen name="Login" component={LoginScreen} />
            <Stack.Screen name="Signup" component={SignupScreen} />
          </>
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
}

export default function App() {
  return (
    <AuthProvider>
      <Navigation />
    </AuthProvider>
  );
}

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
});

===== FILE: ./apps/mobile/ios/mobile/Images.xcassets/AppIcon.appiconset/Contents.json =====
{
  "images" : [
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}


===== FILE: ./apps/mobile/ios/mobile/Images.xcassets/Contents.json =====
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}


===== FILE: ./apps/mobile/package.json =====
{
  "name": "@frontend/mobile",
  "version": "0.0.1",
  "private": true,
  "scripts": {
    "android": "react-native run-android",
    "ios": "react-native run-ios",
    "lint": "eslint .",
    "start": "react-native start",
    "test": "jest"
  },
  "dependencies": {
    "@maplibre/maplibre-react-native": "10.0.0-alpha.26",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "react": "18.3.1",
    "react-native": "0.75.4",
    "react-native-config": "^1.5.1",
    "zustand": "^5.0.8",
     "@hike-tracker/shared-types": "*",
    "@hike-tracker/api-client": "*",
    "@hike-tracker/auth": "*",
    "@hike-tracker/stores": "*",
    "@hike-tracker/utils": "*",
    "@hike-tracker/config": "*"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@babel/preset-env": "^7.25.3",
    "@babel/runtime": "^7.25.0",
    "@react-native-community/cli": "^14.0.0",
    "@react-native-community/cli-platform-android": "^14.0.0",
    "@react-native-community/cli-platform-ios": "^14.0.0",
    "@react-native/babel-preset": "0.75.4",
    "@react-native/eslint-config": "0.75.4",
    "@react-native/metro-config": "0.75.4",
    "@react-native/typescript-config": "0.75.4",
    "@types/react": "^18.2.6",
    "@types/react-test-renderer": "^18.0.0",
    "babel-jest": "^29.6.3",
    "eslint": "^8.19.0",
    "jest": "^29.6.3",
    "prettier": "2.8.8",
    "react-test-renderer": "18.3.1",
    "typescript": "5.0.4"
  },
  "engines": {
    "node": ">=18"
  }
}


===== FILE: ./apps/mobile/src/context/AuthContext.tsx =====
import React, { createContext, useState, useContext, useEffect } from 'react';
import { AuthService } from '@hike-tracker/auth';
import { apiClient } from '@hike-tracker/api-client';
import { useAuthStore } from '@hike-tracker/stores';
import type { SocialProvider } from '@hike-tracker/shared-types';
import { mobileStorageAdapter } from '../utils/storageAdapter';

const authService = new AuthService(apiClient, mobileStorageAdapter);

type User = {
  id: string;
  username: string;
  email: string;
};

// type AuthContextType = {
//   user: User | null;
//   isLoading: boolean;
//   login: (username: string, password: string) => Promise<void>;
//   loginWithGoogle: () => Promise<void>;
//   loginWithFacebook: () => Promise<void>;
//   loginWithInstagram: () => Promise<void>;
//   signup: (username: string, email: string, password: string) => Promise<void>;
//   logout: () => Promise<void>;
// };

type AuthContextType = {
  login: (username: string, password: string) => Promise<void>;
  signup: (username: string, email: string, password: string) => Promise<void>;
  socialLogin: (provider: SocialProvider) => Promise<void>;
  logout: () => Promise<void>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { setAuth, setLoading, logout: clearAuth } = useAuthStore();

  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      setLoading(true);
      const user = await authService.getCurrentUser();
      const tokens = await authService.getTokens();
      setAuth(user, tokens);
    } catch (error) {
      console.error('Error checking auth:', error);
      setAuth(null, null);
    } finally {
      setLoading(false);
    }
  };

  const login = async (username: string, password: string) => {
    const { user, tokens } = await authService.login(username, password);
    setAuth(user, tokens);
  };

  const signup = async (username: string, email: string, password: string) => {
    const { user, tokens } = await authService.signup(username, email, password);
    setAuth(user, tokens);
  };

  const socialLogin = async (provider: SocialProvider) => {
    // TODO: Implement actual OAuth flow
    // For now, using mock token
    const { user, tokens } = await authService.socialLogin(provider, 'mock_token');
    setAuth(user, tokens);
  };

  const logout = async () => {
    await authService.logout();
    clearAuth();
  };

  return (
    <AuthContext.Provider
      value={{
        login,
        signup,
        socialLogin,
        logout,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

===== FILE: ./apps/mobile/src/hooks/useLocation.ts =====
import { useEffect, useState } from 'react';
import LocationModule, { LocationUpdate } from '../native/LocationModule';

export function useLocation() {
  const [location, setLocation] = useState<LocationUpdate | null>(null);

  useEffect(() => {
    // Start updates
    LocationModule.startUpdates();

    // Subscribe to native events
    const sub = LocationModule.addListener((event) => {
      console.log("üìç Got location from native:", event);
      setLocation(event);
    });

    return () => {
      sub.remove();
      LocationModule.stopUpdates();
    };
  }, []);

  return location;
}


===== FILE: ./apps/mobile/src/modules/location/index.ts =====
import { NativeModules } from 'react-native';

const { LocationModule } = NativeModules;

export default {
  start: (): void => {
    LocationModule.start();
  },
  stop: (): void => {
    LocationModule.stop();
  }
};


===== FILE: ./apps/mobile/src/native/LocationModule.ts =====
import { NativeModules, NativeEventEmitter, EmitterSubscription } from 'react-native';

const { LocationModule } = NativeModules;

// ‚úÖ Strong typing for the event payload
export type LocationUpdate = {
  latitude: number;
  longitude: number;
  altitude: number;
  accuracy: number;
  timestamp: number;
};

export type TrackingMode = 'REAL_TIME' | 'MODERATE' | 'BATTERY_EFFICIENT';

const locationEmitter = LocationModule ? new NativeEventEmitter(LocationModule) : null;

export default {
  setTrackingMode(mode: TrackingMode): Promise<void> {
    return LocationModule?.setTrackingMode(mode) || Promise.resolve();
  },
  startUpdates(): Promise<void> {
    return LocationModule?.startUpdates() || Promise.resolve();
  },
  stopUpdates(): Promise<void> {
    return LocationModule?.stopUpdates() || Promise.resolve();
  },
  addListener(
    callback: (update: LocationUpdate) => void
  ): EmitterSubscription {
    if (!locationEmitter) {
      // Return a dummy subscription if no emitter
      return {
        remove: () => {},
      } as EmitterSubscription;
    }
    return locationEmitter.addListener('LocationUpdate', callback);
  },
};


===== FILE: ./apps/mobile/src/screens/LoginScreen.tsx =====
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Alert,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useAuth } from '../context/AuthContext';

type LoginScreenProps = {
  navigation: any;
};

export default function LoginScreen({ navigation }: LoginScreenProps) {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const { login, socialLogin } = useAuth();

  const handleLogin = async () => {
    if (!username.trim() || !password.trim()) {
      Alert.alert('Error', 'Please enter username and password');
      return;
    }

    setLoading(true);
    try {
      await login(username, password);
    } catch (error) {
      Alert.alert('Login Failed', error instanceof Error ? error.message : 'Invalid credentials');
    } finally {
      setLoading(false);
    }
  };

  const handleSocialLogin = async (provider: 'google' | 'facebook' | 'instagram') => {
    setLoading(true);
    try {
      await socialLogin(provider);
    } catch (error) {
      Alert.alert('Login Failed', `Could not login with ${provider}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.header}>
          <Text style={styles.logo}>ü•æ</Text>
          <Text style={styles.title}>TrackSter</Text>
          <Text style={styles.subtitle}>Track your adventures</Text>
        </View>

        <View style={styles.form}>
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Username</Text>
            <TextInput
              style={styles.input}
              placeholder="Enter your username"
              placeholderTextColor="#999"
              value={username}
              onChangeText={setUsername}
              autoCapitalize="none"
              autoCorrect={false}
              editable={!loading}
            />
          </View>

          <View style={styles.inputContainer}>
            <Text style={styles.label}>Password</Text>
            <TextInput
              style={styles.input}
              placeholder="Enter your password"
              placeholderTextColor="#999"
              value={password}
              onChangeText={setPassword}
              secureTextEntry
              autoCapitalize="none"
              editable={!loading}
            />
          </View>

          <TouchableOpacity
            style={[styles.loginButton, loading && styles.buttonDisabled]}
            onPress={handleLogin}
            disabled={loading}
          >
            {loading ? (
              <ActivityIndicator color="#fff" />
            ) : (
              <Text style={styles.loginButtonText}>Log In</Text>
            )}
          </TouchableOpacity>

          <View style={styles.divider}>
            <View style={styles.dividerLine} />
            <Text style={styles.dividerText}>OR</Text>
            <View style={styles.dividerLine} />
          </View>

          <TouchableOpacity
            style={[styles.socialButton, styles.googleButton]}
            onPress={() => handleSocialLogin('google')}
            disabled={loading}
          >
            <Text style={styles.socialButtonText}>üîç Continue with Google</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.socialButton, styles.facebookButton]}
            onPress={() => handleSocialLogin('facebook')}
            disabled={loading}
          >
            <Text style={styles.socialButtonText}>üìò Continue with Facebook</Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.socialButton, styles.instagramButton]}
            onPress={() => handleSocialLogin('instagram')}
            disabled={loading}
          >
            <Text style={styles.socialButtonText}>üì∑ Continue with Instagram</Text>
          </TouchableOpacity>

          <View style={styles.signupContainer}>
            <Text style={styles.signupText}>Don't have an account? </Text>
            <TouchableOpacity
              onPress={() => navigation.navigate('Signup')}
              disabled={loading}
            >
              <Text style={styles.signupLink}>Sign Up</Text>
            </TouchableOpacity>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    flexGrow: 1,
    justifyContent: 'center',
    padding: 20,
  },
  header: {
    alignItems: 'center',
    marginBottom: 40,
  },
  logo: {
    fontSize: 60,
    marginBottom: 10,
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 5,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
  form: {
    width: '100%',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 15,
    paddingVertical: 12,
    fontSize: 16,
    color: '#333',
  },
  loginButton: {
    backgroundColor: '#4CAF50',
    borderRadius: 8,
    paddingVertical: 15,
    alignItems: 'center',
    marginTop: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  buttonDisabled: {
    opacity: 0.6,
  },
  loginButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  divider: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 30,
  },
  dividerLine: {
    flex: 1,
    height: 1,
    backgroundColor: '#ddd',
  },
  dividerText: {
    color: '#999',
    paddingHorizontal: 10,
    fontSize: 14,
  },
  socialButton: {
    borderRadius: 8,
    paddingVertical: 15,
    alignItems: 'center',
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#ddd',
    backgroundColor: '#fff',
  },
  googleButton: {
    borderColor: '#DB4437',
  },
  facebookButton: {
    borderColor: '#4267B2',
  },
  instagramButton: {
    borderColor: '#E1306C',
  },
  socialButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  signupContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 30,
  },
  signupText: {
    color: '#666',
    fontSize: 14,
  },
  signupLink: {
    color: '#4CAF50',
    fontSize: 14,
    fontWeight: 'bold',
  },
});

===== FILE: ./apps/mobile/src/screens/MapScreen.tsx =====
import React, { useEffect, useRef, useState } from 'react';
import { View, Button, Platform, PermissionsAndroid, Text, Alert, StyleSheet, TouchableOpacity, Modal} from 'react-native';
import MapLibreGL from '@maplibre/maplibre-react-native';
import { useTrackingStore, useAuthStore } from '@hike-tracker/stores';
import { apiClient } from '@hike-tracker/api-client';
import { config } from '@hike-tracker/config';
import { formatCoordinates, calculatePathDistance, formatDistance } from '@hike-tracker/utils';
import { sendBatch } from '../services/ingest';
import LocationModule, { LocationUpdate, TrackingMode } from '../native/LocationModule';
import { useAuth } from '../context/AuthContext';

MapLibreGL.setAccessToken(null);

const STYLE = {
  version: 8,
  sources: {
    osm: {
      type: 'raster',
      // tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
      tiles: [config.map.tileUrl],
      tileSize: 256,
      attribution: '¬© OpenStreetMap',
    },
  },
  layers: [
    {
      id: 'osm',
      type: 'raster',
      source: 'osm',
    },
  ],
};

const TRACKING_MODES: Array<{
  mode: TrackingMode;
  label: string;
  description: string;
  icon: string;
}> = [
  {
    mode: 'REAL_TIME',
    label: 'Real-Time',
    description: 'Most accurate\nHighest battery usage',
    icon: 'üî•',
  },
  {
    mode: 'MODERATE',
    label: 'Moderate',
    description: 'Balanced accuracy\nand battery',
    icon: '‚ö°',
  },
  {
    mode: 'BATTERY_EFFICIENT',
    label: 'Battery Saver',
    description: 'Lower accuracy\nBest battery life',
    icon: 'üîã',
  },
];


export default function MapScreen() {
  const { isTracking, start, stop, pushPoint, hikerId, drainBuffer, trackingMode, setTrackingMode } = useTrackingStore();
  const [granted, setGranted] = useState(false);
  const [currentLocation, setCurrentLocation] = useState<[number, number]>(config.map.defaultLocation);
  const [hasLocation, setHasLocation] = useState(false);
  const [pathCoordinates, setPathCoordinates] = useState<[number, number][]>([]);
  const [lastAltitude, setLastAltitude] = useState<number>(0);
  const [showModeSelector, setShowModeSelector] = useState(false);

  const cameraRef = useRef<any>(null);
  const subRef = useRef<{ remove: () => void } | null>(null);
  const flushTimerRef = useRef<NodeJS.Timeout | null>(null);

  useEffect(() => {
    if (user) {
      setHikerId(user.id);
    }
  }, [user]);

  async function askPerms() {
    if (Platform.OS === 'android') {
      const fine = await PermissionsAndroid.request(
        PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION
      );
      setGranted(fine === 'granted');
    } else {
      setGranted(true);
    }
  }

  useEffect(() => { 
    askPerms(); 
  }, []);

  useEffect(() => {
    console.log('üîµ Effect running - granted:', granted, 'isTracking:', isTracking);
    
    if (!granted || !isTracking || !user) return;
    
    console.log('üü¢ Starting location updates with mode:', trackingMode);

    LocationModule.setTrackingMode(trackingMode);
    
    if (LocationModule?.startUpdates) {
      LocationModule.startUpdates();
      console.log('üü¢ LocationModule.startUpdates() called');
      
      subRef.current = LocationModule.addListener((pos: LocationUpdate) => {
        console.log('üìç Location:', pos.latitude, pos.longitude);
        const newLocation: [number, number] = [pos.longitude, pos.latitude];
        setCurrentLocation(newLocation);
        setHasLocation(true);
        setLastAltitude(pos.altitude);
        setPathCoordinates(prev => [...prev, newLocation]);

        if (cameraRef.current) {
          cameraRef.current.setCamera({
            centerCoordinate: newLocation,
            zoomLevel: 15,
            animationDuration: 1000,
          });
        }
        
        pushPoint({
          hikerId,
          latitude: pos.latitude,
          longitude: pos.longitude,
          altitude: pos.altitude,
          recordedAt: new Date().toISOString()
        });
      });
    }

    flushTimerRef.current = setInterval(async () => {
      const batch = drainBuffer();
      if (batch.length && tokens?.accessToken) {
        console.log('üì§ Sending batch:', batch.length, 'points');
        try { 
          await apiClient.sendBatch(tokens.accessToken, batch); 
        } catch (e) { 
          console.warn('sendBatch failed; will retry next tick', e); 
        }
      }
    }, 60000);

    return () => {
      subRef.current?.remove();
      LocationModule?.stopUpdates();
      if (flushTimerRef.current) {
        clearInterval(flushTimerRef.current);
        flushTimerRef.current = null;
      }
    };
  }, [isTracking, granted, hikerId, pushPoint, drainBuffer, trackingMode]);

  const onStart = () => {
    console.log('üîµ START button clicked!');
    setPathCoordinates([]);
    start();
  };
  
  const onStop = async () => {
    console.log('üî¥ STOP button clicked!');
    stop();
    const batch = drainBuffer();
    if (batch.length && tokens?.accessToken) {
      try { 
        await apiClient.sendBatch(tokens.accessToken, batch); 
      } catch { 
        Alert.alert('Upload failed; will retry next time'); 
      }
    }
  };

  // ‚úÖ NEW: Home button handler
  const onHome = () => {
    Alert.alert(
      'Salut Domnule Soarec !!!',
      `You are at: ${currentLocation[1].toFixed(6)}, ${currentLocation[0].toFixed(6)}\nPath points: ${pathCoordinates.length}`,
      [{ text: 'OK' }]
    );
  };

  const handleModeSelect = (mode: TrackingMode) => {
    setTrackingMode(mode);
    setShowModeSelector(false);
    
    // If currently tracking, restart with new mode
    if (isTracking) {
      Alert.alert(
        'Mode Changed',
        `Switching to ${mode.replace('_', ' ')} mode. This will take effect on the next location update.`,
        [{ text: 'OK' }]
      );
      LocationModule.setTrackingMode(mode);
    }
  };

  const pathGeoJSON = {
    type: 'FeatureCollection' as const,
    features: [
      {
        type: 'Feature' as const,
        geometry: {
          type: 'LineString' as const,
          coordinates: pathCoordinates,
        },
        properties: {},
      },
    ],
  };

  const currentModeInfo = TRACKING_MODES.find(m => m.mode === trackingMode);

  return (
    <View style={styles.container}>
      <MapLibreGL.MapView 
        style={styles.map}
        styleJSON={JSON.stringify(STYLE)}
        logoEnabled={false}
        pointerEvents="box-none"
      >
        <MapLibreGL.Camera 
          ref={cameraRef}
          zoomLevel={15} 
          centerCoordinate={currentLocation}
        />

        {pathCoordinates.length > 1 && (
          <MapLibreGL.ShapeSource
            id="path-source"
            shape={pathGeoJSON}
          >
            <MapLibreGL.LineLayer
              id="path-layer"
              style={{
                lineColor: '#FF0000',
                lineWidth: 4,
                lineCap: 'round',
                lineJoin: 'round',
              }}
            />
          </MapLibreGL.ShapeSource>
        )}
        
        {hasLocation && (
          <MapLibreGL.PointAnnotation 
            id="current-location" 
            coordinate={currentLocation}
          >
            <View style={styles.marker}>
              <View style={styles.markerInner} />
            </View>
          </MapLibreGL.PointAnnotation>
        )}
      </MapLibreGL.MapView>

      <View style={styles.status}>
  <Text style={styles.statusText}>
    {granted ? 'üìç Location OK' : '‚ö†Ô∏è Location permission needed'}
  </Text>
  <Text style={styles.trackingText}>
    {isTracking ? 'üî¥ Tracking Active' : '‚ö™ Not Tracking'}
  </Text>
  <TouchableOpacity 
    style={styles.modeButton} 
    onPress={() => setShowModeSelector(true)}
  >
    <Text style={styles.modeText}>
      {currentModeInfo?.icon} {currentModeInfo?.label}
    </Text>
  </TouchableOpacity>
  {hasLocation && (
    <>
      <Text style={styles.coordText}>
        Lat: {currentLocation[1].toFixed(6)}, Lon: {currentLocation[0].toFixed(6)}
      </Text>
      <Text style={styles.altitudeText}>
        Altitude: {hasLocation && lastAltitude ? `${lastAltitude.toFixed(1)}m` : 'N/A'}
      </Text>
      <Text style={styles.pathText}>
        Path: {pathCoordinates.length} points
            </Text>
          </>
        )}
      </View>

      {/* ‚úÖ CHANGED: Button layout with two buttons side by side */}
      <View style={styles.controls}>
        <View style={styles.buttonRow}>
          <TouchableOpacity 
            style={[styles.button, isTracking ? styles.buttonStop : styles.buttonStart]}
            onPress={isTracking ? onStop : onStart}
          >
            <Text style={styles.buttonText}>
              {isTracking ? "Stop" : "Start"}
            </Text>
          </TouchableOpacity>
          
          <TouchableOpacity 
            style={[styles.button, styles.buttonHome]}
            onPress={onHome}
          >
            <Text style={styles.buttonText}>Home</Text>
          </TouchableOpacity>
        </View>
      </View>
       {/* Mode Selector Modal */}
      <Modal
        visible={showModeSelector}
        transparent
        animationType="fade"
        onRequestClose={() => setShowModeSelector(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>Select Tracking Mode</Text>
            
            {TRACKING_MODES.map((modeInfo) => (
              <TouchableOpacity
                key={modeInfo.mode}
                style={[
                  styles.modeOption,
                  trackingMode === modeInfo.mode && styles.modeOptionSelected
                ]}
                onPress={() => handleModeSelect(modeInfo.mode)}
              >
                <Text style={styles.modeIcon}>{modeInfo.icon}</Text>
                <View style={styles.modeInfo}>
                  <Text style={styles.modeLabel}>{modeInfo.label}</Text>
                  <Text style={styles.modeDescription}>{modeInfo.description}</Text>
                </View>
                {trackingMode === modeInfo.mode && (
                  <Text style={styles.checkmark}>‚úì</Text>
                )}
              </TouchableOpacity>
            ))}

            <TouchableOpacity 
              style={styles.modalCloseButton}
              onPress={() => setShowModeSelector(false)}
            >
              <Text style={styles.modalCloseText}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  map: {
    flex: 1,
  },
  status: {
    position: 'absolute',
    top: 40,
    left: 16,
    right: 16,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
    padding: 12,
    borderRadius: 8,
  },
  statusText: {
    color: 'white',
    fontSize: 14,
    marginBottom: 4,
  },
  trackingText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
  },
   modeButton: {
    backgroundColor: 'rgba(33, 150, 243, 0.3)',
    paddingVertical: 6,
    paddingHorizontal: 12,
    borderRadius: 6,
    marginVertical: 6,
    alignSelf: 'flex-start',
  },
  modeText: {
    color: '#64B5F6',
    fontSize: 12,
    fontWeight: 'bold',
  },
  coordText: {
    color: '#4CAF50',
    fontSize: 12,
    fontFamily: 'monospace',
  },
  pathText: {
    color: '#FF5722',
    fontSize: 12,
    marginTop: 4,
    fontWeight: 'bold',
  },
  controls: {
    position: 'absolute',
    bottom: 40,
    left: 16,
    right: 16,
  },
  // ‚úÖ NEW: Styles for button layout
  buttonRow: {
    flexDirection: 'row',
    gap: 12,
  },
   button: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  buttonStart: {
    backgroundColor: '#4CAF50',
  },
  buttonStop: {
    backgroundColor: '#F44336',
  },
  buttonHome: {
    backgroundColor: '#2196F3',
  },
  buttonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  marker: {
    width: 30,
    height: 30,
    borderRadius: 15,
    backgroundColor: 'rgba(66, 133, 244, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  markerInner: {
    width: 16,
    height: 16,
    borderRadius: 8,
    backgroundColor: '#4285F4',
    borderWidth: 2,
    borderColor: 'white',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: 'white',
    borderRadius: 12,
    padding: 20,
    width: '85%',
    maxWidth: 400,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
  },
  modeOption: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    backgroundColor: '#f5f5f5',
  },
  modeOptionSelected: {
    backgroundColor: '#E3F2FD',
    borderWidth: 2,
    borderColor: '#2196F3',
  },
  modeIcon: {
    fontSize: 32,
    marginRight: 12,
  },
  modeInfo: {
    flex: 1,
  },
  modeLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  modeDescription: {
    fontSize: 12,
    color: '#666',
  },
  checkmark: {
    fontSize: 24,
    color: '#2196F3',
    fontWeight: 'bold',
  },
  modalCloseButton: {
    marginTop: 8,
    padding: 12,
    backgroundColor: '#2196F3',
    borderRadius: 8,
    alignItems: 'center',
  },
  modalCloseText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  altitudeText: {
  color: '#2196F3',
  fontSize: 12,
  marginTop: 2,
  fontWeight: 'bold',
}
});

===== FILE: ./apps/mobile/src/screens/SignupScreen.tsx =====
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Alert,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { useAuth } from '../context/AuthContext';

type SignupScreenProps = {
  navigation: any;
};

export default function SignupScreen({ navigation }: SignupScreenProps) {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const { signup } = useAuth();

  const validateEmail = (email: string) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  };

  const handleSignup = async () => {
    if (!username.trim() || !email.trim() || !password.trim() || !confirmPassword.trim()) {
      Alert.alert('Error', 'Please fill in all fields');
      return;
    }

    if (!validateEmail(email)) {
      Alert.alert('Error', 'Please enter a valid email address');
      return;
    }

    if (password.length < 6) {
      Alert.alert('Error', 'Password must be at least 6 characters');
      return;
    }

    if (password !== confirmPassword) {
      Alert.alert('Error', 'Passwords do not match');
      return;
    }

    setLoading(true);
    try {
      await signup(username, email, password);
    } catch (error) {
      Alert.alert('Signup Failed', 'Could not create account. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.header}>
          <Text style={styles.logo}>ü•æ</Text>
          <Text style={styles.title}>Create Account</Text>
          <Text style={styles.subtitle}>Join us and start tracking your hikes</Text>
        </View>

        <View style={styles.form}>
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Username</Text>
            <TextInput
              style={styles.input}
              placeholder="Choose a username"
              placeholderTextColor="#999"
              value={username}
              onChangeText={setUsername}
              autoCapitalize="none"
              autoCorrect={false}
              editable={!loading}
            />
          </View>

          <View style={styles.inputContainer}>
            <Text style={styles.label}>Email</Text>
            <TextInput
              style={styles.input}
              placeholder="Enter your email"
              placeholderTextColor="#999"
              value={email}
              onChangeText={setEmail}
              autoCapitalize="none"
              autoCorrect={false}
              keyboardType="email-address"
              editable={!loading}
            />
          </View>

          <View style={styles.inputContainer}>
            <Text style={styles.label}>Password</Text>
            <TextInput
              style={styles.input}
              placeholder="Create a password (min 6 characters)"
              placeholderTextColor="#999"
              value={password}
              onChangeText={setPassword}
              secureTextEntry
              autoCapitalize="none"
              editable={!loading}
            />
          </View>

          <View style={styles.inputContainer}>
            <Text style={styles.label}>Confirm Password</Text>
            <TextInput
              style={styles.input}
              placeholder="Re-enter your password"
              placeholderTextColor="#999"
              value={confirmPassword}
              onChangeText={setConfirmPassword}
              secureTextEntry
              autoCapitalize="none"
              editable={!loading}
            />
          </View>

          <TouchableOpacity
            style={[styles.signupButton, loading && styles.buttonDisabled]}
            onPress={handleSignup}
            disabled={loading}
          >
            {loading ? (
              <ActivityIndicator color="#fff" />
            ) : (
              <Text style={styles.signupButtonText}>Sign Up</Text>
            )}
          </TouchableOpacity>

          <View style={styles.loginContainer}>
            <Text style={styles.loginText}>Already have an account? </Text>
            <TouchableOpacity
              onPress={() => navigation.navigate('Login')}
              disabled={loading}
            >
              <Text style={styles.loginLink}>Log In</Text>
            </TouchableOpacity>
          </View>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  scrollContent: {
    flexGrow: 1,
    justifyContent: 'center',
    padding: 20,
  },
  header: {
    alignItems: 'center',
    marginBottom: 40,
  },
  logo: {
    fontSize: 60,
    marginBottom: 10,
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 5,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  form: {
    width: '100%',
  },
  inputContainer: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    paddingHorizontal: 15,
    paddingVertical: 12,
    fontSize: 16,
    color: '#333',
  },
  signupButton: {
    backgroundColor: '#4CAF50',
    borderRadius: 8,
    paddingVertical: 15,
    alignItems: 'center',
    marginTop: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  buttonDisabled: {
    opacity: 0.6,
  },
  signupButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  loginContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: 30,
  },
  loginText: {
    color: '#667',
    fontSize: 14,
  },
  loginLink: {
    color: '#4CAF50',
    fontSize: 14,
    fontWeight: 'bold',
  },
});

===== FILE: ./apps/mobile/src/services/ingest.ts =====
import { create } from 'zustand';
import { Platform } from 'react-native';
import Config from 'react-native-config';

type Point = { hikerId: string; latitude: number; longitude: number; altitude: number; recordedAt: string };

type State = {
  hikerId: string;
  isTracking: boolean;
  buffer: Point[];
  setHikerId: (id: string) => void;
  start: () => void;
  stop: () => void;
  pushPoint: (p: Point) => void;
  drainBuffer: () => Point[];
};

function baseUrl() {
  return Platform.OS === 'android'
    ? Config.BACKEND_BASE_URL_ANDROID
    : Config.BACKEND_BASE_URL_IOS;
}

export const useTrackingStore = create<State>((set, get) => ({
  hikerId: 'hiker1',
  isTracking: false,
  buffer: [],
  setHikerId: (id) => set({ hikerId: id }),
  start: () => set({ isTracking: true }),
  stop: () => set({ isTracking: false }),
  pushPoint: (p) => set({ buffer: [...get().buffer, p] }),
  drainBuffer: () => {
    const out = get().buffer;
    set({ buffer: [] });
    return out;
  }
}));

export async function sendBatch(points: Array<{
  hikerId: string; latitude: number; longitude: number; altitude: number; recordedAt: string;
}>) {
  const body = {
    deviceId: 'emulator-device',
    batchId: `batch-${Date.now()}`,
    idempotencyKey: `key-${Date.now()}`,
    points,
  };

  const res = await fetch(`${baseUrl()}/v1/ingest/points`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`Ingest failed ${res.status} ${text}`);
  }
}


===== FILE: ./apps/mobile/src/state/useTrackingState.ts =====
import { create } from 'zustand';
import { TrackingMode } from '../native/LocationModule';

type Point = { hikerId: string; latitude: number; longitude: number; altitude:number; recordedAt: string };

type State = {
  hikerId: string;
  isTracking: boolean;
  buffer: Point[];
  trackingMode: TrackingMode;
  setHikerId: (id: string) => void;
  setTrackingMode: (mode: TrackingMode) => void;
  start: () => void;
  stop: () => void;
  pushPoint: (p: Point) => void;
  drainBuffer: () => Point[];
};

export const useTrackingStore = create<State>((set, get) => ({
  hikerId: 'hiker1',
  isTracking: false,
  buffer: [],
  trackingMode: 'MODERATE',
  setHikerId: (id) => set({ hikerId: id }),
  setTrackingMode: (mode) => set({ trackingMode: mode }),
  start: () => set({ isTracking: true }),
  stop: () => set({ isTracking: false }),
  pushPoint: (p) => set({ buffer: [...get().buffer, p] }),
  drainBuffer: () => {
    const out = get().buffer;
    set({ buffer: [] });
    return out;
  }
}));


===== FILE: ./apps/mobile/src/utils/storageAdapter.ts =====
import AsyncStorage from '@react-native-async-storage/async-storage';
import type { StorageAdapter } from '@hike-tracker/auth';

export const mobileStorageAdapter: StorageAdapter = {
  async setItem(key: string, value: string): Promise<void> {
    await AsyncStorage.setItem(key, value);
  },

  async getItem(key: string): Promise<string | null> {
    return await AsyncStorage.getItem(key);
  },

  async removeItem(key: string): Promise<void> {
    await AsyncStorage.removeItem(key);
  },
};

===== FILE: ./apps/mobile/tsconfig.json =====
{
  "extends": "@react-native/typescript-config/tsconfig.json",
  "include": ["**/*.ts", "**/*.tsx", "src"],
  "exclude": ["**/node_modules", "**/Pods"]
  // "compilerOptions": {
  //   "strict": true,
  //   "esModuleInterop": true,
  //   "allowSyntheticDefaultImports": true,
  //   "moduleResolution": "node",
  //   "jsx": "react-native",
  //   "target": "esnext",
  //   "lib": ["esnext"]
  // }
}


===== FILE: ./apps/mobile/__tests__/App.test.tsx =====
/**
 * @format
 */

import 'react-native';
import React from 'react';
import App from '../App';

// Note: import explicitly to use the types shipped with jest.
import {it} from '@jest/globals';

// Note: test renderer must be required after react-native.
import renderer from 'react-test-renderer';

it('renders correctly', () => {
  renderer.create(<App />);
});


===== FILE: ./apps/web/package.json =====
{
  "name": "@frontend/web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^19.1.1",
    "react-dom": "^19.1.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@types/node": "^24.6.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.45.0",
    "vite": "^7.1.7"
  }
}


===== FILE: ./apps/web/src/App.tsx =====
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'

function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/App.tsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App


===== FILE: ./apps/web/src/main.tsx =====
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


===== FILE: ./apps/web/tsconfig.app.json =====
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


===== FILE: ./apps/web/tsconfig.json =====
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


===== FILE: ./apps/web/tsconfig.node.json =====
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


===== FILE: ./apps/web/vite.config.ts =====
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})


===== FILE: ./package.json =====
{
  "name": "frontend",
  "private": true,
  "workspaces": {
    "packages": ["apps/*",
      "packages/*"],
    "nohoist": [
      "**/react",
      "**/react/**",
      "**/react-native",
      "**/react-native/**",
      "**/@react-native/**"
    ]
  },
  "scripts": {
    "mobile": "yarn workspace @frontend/mobile android",
    "web": "yarn workspace @frontend/web dev",
    "web:build": "yarn workspace @frontend/web build"
  }
}


===== FILE: ./packages/api-client/package.json =====
{
  "name": "@hike-tracker/api-client",
  "version": "1.0.0",
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "private": true,
  "scripts": {
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@hike-tracker/shared-types": "*"
  },
  "devDependencies": {
    "typescript": "^5.0.4"
  }
}

===== FILE: ./packages/api-client/src/index.ts =====
import type {
  User,
  LoginRequest,
  SignupRequest,
  AuthResponse,
  Point,
  IngestBatchRequest,
  SocialAuthRequest,
  ApiError,
  TrackingSession,
} from '@hike-tracker/shared-types';

export class ApiClient {
  private baseUrl: string;
  private timeout: number;

  constructor(baseUrl: string, timeout: number = 30000) {
    this.baseUrl = baseUrl;
    this.timeout = timeout;
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        signal: controller.signal,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const error: ApiError = await response.json().catch(() => ({
          code: 'UNKNOWN_ERROR',
          message: `Request failed with status ${response.status}`,
        }));
        throw new Error(error.message);
      }

      return response.json();
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof Error) {
        if (error.name === 'AbortError') {
          throw new Error('Request timeout');
        }
        throw error;
      }
      throw new Error('Unknown error occurred');
    }
  }

  // Auth endpoints
  async login(data: LoginRequest): Promise<AuthResponse> {
    // TODO: Replace with real API call
    // Mock implementation for now
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          user: {
            id: '1',
            username: data.username,
            email: `${data.username}@example.com`,
            createdAt: new Date().toISOString(),
          },
          tokens: {
            accessToken: 'mock_access_token',
            refreshToken: 'mock_refresh_token',
          },
        });
      }, 500);
    });

    // Real implementation:
    // return this.request<AuthResponse>('/auth/login', {
    //   method: 'POST',
    //   body: JSON.stringify(data),
    // });
  }

  async signup(data: SignupRequest): Promise<AuthResponse> {
    // TODO: Replace with real API call
    // Mock implementation for now
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          user: {
            id: Date.now().toString(),
            username: data.username,
            email: data.email,
            createdAt: new Date().toISOString(),
          },
          tokens: {
            accessToken: 'mock_access_token',
            refreshToken: 'mock_refresh_token',
          },
        });
      }, 500);
    });

    // Real implementation:
    // return this.request<AuthResponse>('/auth/signup', {
    //   method: 'POST',
    //   body: JSON.stringify(data),
    // });
  }

  async socialAuth(data: SocialAuthRequest): Promise<AuthResponse> {
    // TODO: Replace with real API call
    // Mock implementation for now
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          user: {
            id: Date.now().toString(),
            username: `${data.provider}_user`,
            email: `user@${data.provider}.com`,
            createdAt: new Date().toISOString(),
          },
          tokens: {
            accessToken: 'mock_access_token',
            refreshToken: 'mock_refresh_token',
          },
        });
      }, 500);
    });

    // Real implementation:
    // return this.request<AuthResponse>('/auth/social', {
    //   method: 'POST',
    //   body: JSON.stringify(data),
    // });
  }

  async refreshToken(refreshToken: string): Promise<AuthResponse> {
    return this.request<AuthResponse>('/auth/refresh', {
      method: 'POST',
      body: JSON.stringify({ refreshToken }),
    });
  }

  async logout(accessToken: string): Promise<void> {
    return this.request<void>('/auth/logout', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });
  }

  // User endpoints
  async getCurrentUser(accessToken: string): Promise<User> {
    return this.request<User>('/users/me', {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });
  }

  async updateUser(
    accessToken: string,
    userId: string,
    data: Partial<User>
  ): Promise<User> {
    return this.request<User>(`/users/${userId}`, {
      method: 'PATCH',
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
      body: JSON.stringify(data),
    });
  }

  // Tracking endpoints
  async sendBatch(
    accessToken: string,
    points: Point[],
    deviceId: string = 'unknown'
  ): Promise<void> {
    const body: IngestBatchRequest = {
      deviceId,
      batchId: `batch-${Date.now()}`,
      idempotencyKey: `key-${Date.now()}`,
      points,
    };

    return this.request<void>('/v1/ingest/points', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
      body: JSON.stringify(body),
    });
  }

  async getTrackingSessions(
    accessToken: string,
    userId: string
  ): Promise<TrackingSession[]> {
    return this.request<TrackingSession[]>(`/tracking/sessions/${userId}`, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });
  }

  async getTrackingSession(
    accessToken: string,
    sessionId: string
  ): Promise<TrackingSession> {
    return this.request<TrackingSession>(`/tracking/sessions/${sessionId}`, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });
  }

  async createTrackingSession(
    accessToken: string,
    userId: string
  ): Promise<TrackingSession> {
    return this.request<TrackingSession>('/tracking/sessions', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
      body: JSON.stringify({ userId }),
    });
  }

  async endTrackingSession(
    accessToken: string,
    sessionId: string
  ): Promise<TrackingSession> {
    return this.request<TrackingSession>(
      `/tracking/sessions/${sessionId}/end`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      }
    );
  }
}

// Export singleton instance
export const apiClient = new ApiClient(
  process.env.BACKEND_BASE_URL || 'http://localhost:3000'
);

===== FILE: ./packages/api-client/tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


===== FILE: ./packages/auth/package.json =====
{
  "name": "@hike-tracker/auth",
  "version": "1.0.0",
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "private": true,
  "scripts": {
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@hike-tracker/shared-types": "*",
    "@hike-tracker/api-client": "*",
    "@hike-tracker/config": "*",
    "@hike-tracker/utils": "*"
  },
  "devDependencies": {
    "typescript": "^5.0.4"
  }
}

===== FILE: ./packages/auth/src/AuthService.ts =====
import type {
  User,
  AuthTokens,
  LoginRequest,
  SignupRequest,
  SocialProvider,
} from '@hike-tracker/shared-types';
import { ApiClient } from '@hike-tracker/api-client';
import { config } from '@hike-tracker/config';
import { validateEmail, validatePassword, validateUsername } from '@hike-tracker/utils';

export interface StorageAdapter {
  setItem(key: string, value: string): Promise<void>;
  getItem(key: string): Promise<string | null>;
  removeItem(key: string): Promise<void>;
}

export class AuthService {
  private apiClient: ApiClient;
  private storage: StorageAdapter;

  constructor(apiClient: ApiClient, storage: StorageAdapter) {
    this.apiClient = apiClient;
    this.storage = storage;
  }

  async login(username: string, password: string): Promise<{ user: User; tokens: AuthTokens }> {
    if (!username.trim()) {
      throw new Error('Username is required');
    }

    if (!password.trim()) {
      throw new Error('Password is required');
    }

    const data: LoginRequest = { username, password };
    const response = await this.apiClient.login(data);

    // Store tokens and user
    await this.saveAuth(response.user, response.tokens);

    return response;
  }

  async signup(username: string, email: string, password: string): Promise<{ user: User; tokens: AuthTokens }> {
    // Validation
    if (!validateUsername(username, config.validation.minUsernameLength, config.validation.maxUsernameLength)) {
      throw new Error(
        `Username must be between ${config.validation.minUsernameLength} and ${config.validation.maxUsernameLength} characters`
      );
    }

    if (!validateEmail(email)) {
      throw new Error('Invalid email address');
    }

    if (!validatePassword(password, config.validation.minPasswordLength)) {
      throw new Error(`Password must be at least ${config.validation.minPasswordLength} characters`);
    }

    const data: SignupRequest = { username, email, password };
    const response = await this.apiClient.signup(data);

    // Store tokens and user
    await this.saveAuth(response.user, response.tokens);

    return response;
  }

  async socialLogin(provider: SocialProvider, token: string): Promise<{ user: User; tokens: AuthTokens }> {
    const response = await this.apiClient.socialAuth({ provider, token });

    // Store tokens and user
    await this.saveAuth(response.user, response.tokens);

    return response;
  }

  async logout(): Promise<void> {
    const tokens = await this.getTokens();
    
    if (tokens?.accessToken) {
      try {
        await this.apiClient.logout(tokens.accessToken);
      } catch (error) {
        console.warn('Logout API call failed:', error);
        // Continue with local logout even if API call fails
      }
    }

    await this.clearAuth();
  }

  async refreshToken(): Promise<AuthTokens | null> {
    const tokens = await this.getTokens();
    
    if (!tokens?.refreshToken) {
      return null;
    }

    try {
      const response = await this.apiClient.refreshToken(tokens.refreshToken);
      await this.saveAuth(response.user, response.tokens);
      return response.tokens;
    } catch (error) {
      // If refresh fails, clear auth
      await this.clearAuth();
      return null;
    }
  }

  async getCurrentUser(): Promise<User | null> {
    const userJson = await this.storage.getItem(config.auth.userStorageKey);
    if (!userJson) return null;

    try {
      return JSON.parse(userJson);
    } catch {
      return null;
    }
  }

  async getTokens(): Promise<AuthTokens | null> {
    const tokensJson = await this.storage.getItem(config.auth.tokenStorageKey);
    if (!tokensJson) return null;

    try {
      return JSON.parse(tokensJson);
    } catch {
      return null;
    }
  }

  async isAuthenticated(): Promise<boolean> {
    const user = await this.getCurrentUser();
    const tokens = await this.getTokens();
    return !!(user && tokens);
  }

  private async saveAuth(user: User, tokens: AuthTokens): Promise<void> {
    await this.storage.setItem(config.auth.userStorageKey, JSON.stringify(user));
    await this.storage.setItem(config.auth.tokenStorageKey, JSON.stringify(tokens));
  }

  private async clearAuth(): Promise<void> {
    await this.storage.removeItem(config.auth.userStorageKey);
    await this.storage.removeItem(config.auth.tokenStorageKey);
  }
}

===== FILE: ./packages/auth/src/index.ts =====
export { AuthService } from './AuthService';
export type { StorageAdapter } from './AuthService';

===== FILE: ./packages/auth/tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


===== FILE: ./packages/config/package.json =====

{
  "name": "@hike-tracker/config",
  "version": "1.0.0",
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "private": true,
  "scripts": {
    "typecheck": "tsc --noEmit"
  },
  "devDependencies": {
    "typescript": "^5.0.4"
  }
}

===== FILE: ./packages/config/src/index.ts =====
export const config = {
  api: {
    baseUrl: process.env.BACKEND_BASE_URL || 'http://localhost:3000',
    timeout: 30000,
  },
  // tracking: {
  //   updateInterval: 30000, // 30 seconds
  //   minDistance: 30, // 30 meters
  //   flushInterval: 60000, // 1 minute
  //   maxBufferSize: 100, // Maximum points before forced flush
  // },
  auth: {
    tokenStorageKey: 'auth_tokens',
    userStorageKey: 'user_data',
    sessionTimeout: 7 * 24 * 60 * 60 * 1000, // 7 days
  },
  validation: {
    minPasswordLength: 6,
    minUsernameLength: 3,
    maxUsernameLength: 20,
  },
  map: {
    defaultLocation: [-122.084, 37.4219983] as [number, number],
    defaultZoom: 15,
    tileUrl: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
  },
};

export type Config = typeof config;

===== FILE: ./packages/config/tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


===== FILE: ./packages/shared-types/package.json =====
{
  "name": "@hiketracker/types",
  "version": "0.0.1",
  "main": "src/index.ts",
  "types": "src/index.ts",
  "private": true
}

===== FILE: ./packages/shared-types/src/index.ts =====
export type LocationEvent = {
  hikerId: string;
  latitude: number;
  longitude: number;
  timestamp: string; // ISO
};

export type AlertEvent = {
  hikerId: string;
  type: string;
  message: string;
  timestamp: string; // ISO
};


===== FILE: ./packages/shared-types/tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


===== FILE: ./packages/stores/package.json =====
{
  "name": "@hike-tracker/stores",
  "version": "1.0.0",
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "private": true,
  "scripts": {
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@hike-tracker/shared-types": "*",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "typescript": "^5.0.4"
  }
}

===== FILE: ./packages/stores/src/index.ts =====
export { useTrackingStore } from './useTrackingStore';
export { useAuthStore } from './useAuthStore';

===== FILE: ./packages/stores/src/UseAuthStore.ts =====
import { create } from 'zustand';
import type { User, AuthTokens } from '@hike-tracker/shared-types';

type AuthState = {
  user: User | null;
  tokens: AuthTokens | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  setUser: (user: User | null) => void;
  setTokens: (tokens: AuthTokens | null) => void;
  setAuth: (user: User | null, tokens: AuthTokens | null) => void;
  setLoading: (loading: boolean) => void;
  logout: () => void;
};

export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  tokens: null,
  isAuthenticated: false,
  isLoading: true,

  setUser: (user) =>
    set({
      user,
      isAuthenticated: !!user,
    }),

  setTokens: (tokens) =>
    set({
      tokens,
    }),

  setAuth: (user, tokens) =>
    set({
      user,
      tokens,
      isAuthenticated: !!user && !!tokens,
      isLoading: false,
    }),

  setLoading: (loading) =>
    set({
      isLoading: loading,
    }),

  logout: () =>
    set({
      user: null,
      tokens: null,
      isAuthenticated: false,
      isLoading: false,
    }),
}));

===== FILE: ./packages/stores/src/UseTrackingStore.ts =====
import { create } from 'zustand';
import type { Point } from '@hike-tracker/shared-types';

type TrackingState = {
  hikerId: string;
  isTracking: boolean;
  buffer: Point[];
  sessionId: string | null;
  startTime: Date | null;
  setHikerId: (id: string) => void;
  start: (sessionId?: string) => void;
  stop: () => void;
  pushPoint: (p: Point) => void;
  drainBuffer: () => Point[];
  reset: () => void;
};

export const useTrackingStore = create<TrackingState>((set, get) => ({
  hikerId: '',
  isTracking: false,
  buffer: [],
  sessionId: null,
  startTime: null,

  setHikerId: (id) => set({ hikerId: id }),

  start: (sessionId) =>
    set({
      isTracking: true,
      sessionId: sessionId || `session-${Date.now()}`,
      startTime: new Date(),
    }),

  stop: () =>
    set({
      isTracking: false,
      startTime: null,
    }),

  pushPoint: (p) =>
    set((state) => ({
      buffer: [...state.buffer, p],
    })),

  drainBuffer: () => {
    const out = get().buffer;
    set({ buffer: [] });
    return out;
  },

  reset: () =>
    set({
      hikerId: '',
      isTracking: false,
      buffer: [],
      sessionId: null,
      startTime: null,
    }),
}));

===== FILE: ./packages/stores/tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


===== FILE: ./packages/utils/package.json =====
{
  "name": "@hike-tracker/utils",
  "version": "1.0.0",
  "main": "./src/index.ts",
  "types": "./src/index.ts",
  "private": true,
  "scripts": {
    "typecheck": "tsc --noEmit"
  },
  "devDependencies": {
    "typescript": "^5.0.4",
    "@types/node": "^20.0.0"
  }
}

===== FILE: ./packages/utils/src/index.ts =====
// Validation utilities
export const validateEmail = (email: string): boolean => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export const validatePassword = (password: string, minLength: number = 6): boolean => {
  return password.length >= minLength;
};

export const validateUsername = (username: string, minLength: number = 3, maxLength: number = 20): boolean => {
  return username.length >= minLength && username.length <= maxLength;
};

// Formatting utilities
export const formatCoordinates = (lat: number, lon: number, alt: number): string => {
  return `${lat.toFixed(6)}, ${lon.toFixed(6)}, ${alt.toFixed(3)}`;
};

export const formatDistance = (meters: number): string => {
  if (meters < 1000) {
    return `${Math.round(meters)}m`;
  }
  return `${(meters / 1000).toFixed(2)}km`;
};

export const formatDuration = (milliseconds: number): string => {
  const seconds = Math.floor(milliseconds / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  }
  if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  }
  return `${seconds}s`;
};

// Distance calculation using Haversine formula (with altitude)
export const calculateDistance = (
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number,
  alt1: number = 0,
  alt2: number = 0
): number => {
  const R = 6371e3; // Earth's radius in meters
  const œÜ1 = (lat1 * Math.PI) / 180;
  const œÜ2 = (lat2 * Math.PI) / 180;
  const ŒîœÜ = ((lat2 - lat1) * Math.PI) / 180;
  const ŒîŒª = ((lon2 - lon1) * Math.PI) / 180;

  // Haversine distance on Earth's surface
  const a =
    Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
    Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const surfaceDistance = R * c;

  // Include altitude difference
  const heightDiff = alt2 - alt1;
  const totalDistance = Math.sqrt(surfaceDistance ** 2 + heightDiff ** 2);

  return totalDistance; // in meters
};

// Calculate total path distance (with altitude)
export const calculatePathDistance = (
  points: Array<{ latitude: number; longitude: number; altitude?: number }>
): number => {
  if (points.length < 2) return 0;

  let totalDistance = 0;
  for (let i = 1; i < points.length; i++) {
    totalDistance += calculateDistance(
      points[i - 1].latitude,
      points[i - 1].longitude,
      points[i].latitude,
      points[i].longitude,
      points[i - 1].altitude ?? 0,
      points[i].altitude ?? 0
    );
  }
  return totalDistance;
};

// Calculate speed (m/s or km/h)
export const calculateSpeed = (distanceMeters: number, durationMs: number, unit: 'm/s' | 'km/h' = 'm/s'): number => {
  if (durationMs <= 0) return 0;
  const speedMps = distanceMeters / (durationMs / 1000); // meters per second
  return unit === 'km/h' ? speedMps * 3.6 : speedMps;
};

// Date utilities
export const formatDate = (date: Date | string): string => {
  const d = typeof date === 'string' ? new Date(date) : date;
  return d.toLocaleDateString();
};

export const formatDateTime = (date: Date | string): string => {
  const d = typeof date === 'string' ? new Date(date) : date;
  return d.toLocaleString();
};

// Storage utilities (generic, not platform-specific)
export const generateId = (): string => {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};

export const debounce = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout | null = null;
  
  return (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};

export const throttle = <T extends (...args: any[]) => any>(
  func: T,
  limit: number
): ((...args: Parameters<T>) => void) => {
  let inThrottle: boolean;
  
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
};

===== FILE: ./packages/utils/tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}


